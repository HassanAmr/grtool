#!/usr/bin/env python
# -*- encoding: utf-8 -*-
import argparse,subprocess,sys,os,time,select,struct
from select import select

def process(i,o,sub,chn,rate):
    assert len(i)==len(o)

    def close(fd,arr):
        fd.close()
        try: arr.remove(fd)
        except: pass

    labelstream  = i[0]
    l,num,s,e    = None,1,0,0

    # two step process, first we buffer all data and read the first
    # line to get the channel count, which we then pass to ffmpeg.
    # Second step is to write all data to ffmpeg
    channels,chn,buf = [None,]*len(i), os.fdopen(chn,"w"),[[]]*len(i)

    while None in channels:
        r,_,_ = select(i,[],[])

        for fd in r:
            idx = i.index(fd)
            if not channels[idx] is None: continue
            label,data,c = to_binary(fd)
            if c == -1: continue

            channels[idx] = c
            buf[idx].append( data )

            if fd==labelstream:
                l,e = label,1

    chn.write(str(channels)+"\n"); chn.close()

    while sum([len(x) for x in buf]): # emtpy buffers
        _,w,_ = select([],o,[])

        for fd in w:
            idx = o.index(fd)
            for x in buf[idx]: fd.write(x)
            buf[idx] = []

    while len(i) > 0:
        r,_,_ = select(i,[],[])

        for fd in r:
            label,data,c = to_binary(fd)
            idx = i.index(fd)

            # let ffmpeg process know the num of channels
            if channels[idx] is None:
                channels[idx] = len(data)
                if not None in channels:
                    chn.write(str(channels)+"\n")
                    chn.close()

            if data == b"": # empty line
                continue

            if fd == labelstream and label != l:
                srt = "%d\n%d:%d:%d,%d --> %d:%d:%d,%d\n%s\n\n"%(\
                    num,s/(rate*3600), s/(rate*60), s/(rate), (s%rate)/rate*1000,\
                    e/(rate*3600), e/(rate*60), e/(rate), (e%rate)/rate*1000,\
                    l.strip())
                sub.write(srt)
                num,s,l = num+1, e, label if label is not None else l
            e += labelstream == fd

            if data is None: # hit EOF
                close(fd,i)
                close(o[idx],o)
                continue

            if c!=channels[idx]:
                sys.stderr.write("ERROR: dimensionality differs: is %d should be %d\n"%(c,channels[idx]))
                sys.exit(-1)


            o[idx].write(data)

    srt = "%d\n%d:%d:%d,%d --> %d:%d:%d,%d\n%s\n"%(\
            num,s/(rate*3600), s/(rate*60), s/(rate), (s%rate)/rate*1000,\
            e/(rate*3600), e/(rate*60), e/(rate), (e%rate)/rate*1000,\
            l.strip())
    sub.write(srt)
    close(sub,[])


def to_binary(r):
    chunk = r.readline()

    if chunk == "": # EOF
        return None,None,None

    chunk = chunk.strip()
    try: chunk = chunk[:chunk.index('#')] # strip comments
    except: pass

    if chunk=="": # empty line
        return [],b"",-1

    chunk = chunk.split()
    return chunk[0],struct.pack("<%df"%len(chunk[1:]),*(float(f) for f in chunk[1:])),len(chunk)-1

def py3k(tup):
    """ brain-deadness of py3k """
    for x in tup: os.set_inheritable(x,True)
    return tup


def pack_grt(i,rates,names,output,media,verbose=False):
    """ reads lines of data and interprets them in grt format, i.e.:

          label v0 v1 v2 v3 ... vn

        where label is any non-whitescape string, vn are floats of values.
        Values will be packed into a .wavpack file, and labels encoded into a
        subtitle stream.

        Additional media files will also be mux'ed into the output file.
    """
    assert len(i)==len(rates)

    # one pipe for each input file and one for the subtitle stream
    r,w = zip(*[py3k(os.pipe()) for f in i])
    sub = py3k(os.pipe())
    chn = py3k(os.pipe())

    # this is a little involved, since we need to read the first
    # lines of all inputs to know the channel layout to give for
    # encoding, number of channels in audio stream == number of
    # fields in the grt input streams!

    pid = os.fork()
    if pid:
        for p in r: os.close(p)
        w,sub = [os.fdopen(x,"wb") for x in w],os.fdopen(sub[1],"w")
        process(i,w,sub,chn[1],rates[0])
        pid, status = os.waitpid(pid,0)
        return status

    else: # ffmpeg process
        for p in w: os.close(p);
        os.close(sub[1]); os.close(chn[1])

        # wait for parents to send the number of channels for each input channel
        channels = []
        with os.fdopen(chn[0],"r") as f:
            channels=eval(f.readline())

        # copy in all media files, re-encode pipe input as wavpak files,
        # the labels stream from srt to ass format.
        cmd = "ffmpeg -hide_banner -loglevel quiet".split() if not verbose else ["ffmpeg"]
        cmd.extend( arg for f in media for arg in ["-i", f] )
        cmd.extend( arg for (fd,c,rate) in zip(r,channels,rates) for arg in ("-f f32le -ac %d.0 -channel_layout %d.0 -ar %f -i pipe:%d"%(c,c,rate,fd)).split() )
        cmd.extend( ("-f srt -i pipe:%d"%sub[0]).split() )
        cmd.extend( arg for s in range(len(media)+len(r)+1) for arg in ("-map %d:0:%d"%(s,s)).split() )
        cmd.extend( "-c:a wavpack -c:v copy -c:s ass -y -f matroska".split() )
        cmd.append( output )
        #print(" ".join(cmd))
        os.execvp(cmd[0], cmd)

if __name__ == "__main__":
    cmdline = argparse.ArgumentParser("packs grt data (read from stdin) and additional media files into .mkv file")
    cmdline.add_argument('-i', '--input', type=str, default=[], action="append",
            help="grt input file to convert to wavpak/ass file, multiple can be given, if none given defaults to stdin")
    cmdline.add_argument('-n', '--name',  type=str, default=[], action="append", help="names for the input files to be put into the mkv file")
    cmdline.add_argument('-r', '--rate',  type=float, default=[], action="append", help="a rate (in Hz) must be given for each input")
    cmdline.add_argument('-m', '--media', type=str, default=[], action="append",  help="additional file to add, multiple can be given")
    cmdline.add_argument('-v', '--verbose', action="store_true", help="more verbose output")
    cmdline.add_argument('output', type=str, default="-", help="file to pack into")
    args = cmdline.parse_args()

    if len(args.input)==0 and len(args.media)==0:
        args.input = ["-"]

    # make sure that a rate is specified for each input
    print( len(args.rate), len(args.input))

    if len(args.rate) != len(args.input):
        sys.stderr.write("for each input (-i) argument you need to specify the recording rate (-r)\n")
        sys.exit(-1)

    # either read stdin or open all input files
    i = [(open(f,"r") if f!='-' else sys.stdin) for f in args.input]

    pack_grt(i,args.rate,args.name,args.output,args.media,args.verbose)

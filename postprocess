#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, sys, argparse, fileinput, collections, sys
from math import ceil

cmdline = argparse.ArgumentParser('postprocess label outputs')
subpars = cmdline.add_subparsers(help="type of post-processing",dest="command")

major   = subpars.add_parser("majority", help="returns only the label with maximum occurence in the given window" )
major.add_argument("-W","--window", type=int, default=10, help="window size in frames to consider")
major.add_argument("-O","--overlap", type=float, default=.5, help="window overlap")
major.add_argument("-w","--no-warn", action="store_true", help="suppress warnings")
major.add_argument('files', metavar='FILES', type=str, nargs='*',  help="input files or - for stdin")

change  = subpars.add_parser("change", help="return only changed labels")
change.add_argument('files', metavar='FILES', type=str, nargs='*',  help="input files or - for stdin")

mle = subpars.add_parser("confidence", help="maximum likelihood of estimate")
mle.add_argument("-W","--window", type=int, default=10, help="window size in frames to consider")
mle.add_argument("-O","--overlap", type=float, default=.5, help="window overlap")
mle.add_argument('files', metavar='FILES', type=str, nargs='*',  help="input files or - for stdin")

mlc = subpars.add_parser("score", help="maximum likelihood of class")
mlc.add_argument("-W","--window", type=int, default=10, help="window size in frames to consider")
mlc.add_argument("-O","--overlap", type=float, default=.5, help="window overlap")
mlc.add_argument('files', metavar='FILES', type=str, nargs='*',  help="input files or - for stdin")

args = cmdline.parse_args()

def select_first_most_common(l):
    l = list(l)
    c = collections.Counter(l)
    m = max(c.values())
    c = [k for k,v in c.most_common() if v==m]
    c = [k for k in l if k in c]
    return c[0]

def major_print_window(window, args):
    l1 = collections.Counter(l1 for (l1,l2) in window).most_common(1)[0][0]
    l2 = collections.Counter(l2 for (l1,l2) in window).most_common(1)[0][0]

    l1 = select_first_most_common(l1 for (l1,l2) in window)
    l2 = select_first_most_common(l2 for (l1,l2) in window)
    print (l1,l2)

    if not args.no_warn:
        s1 = [ l1 for (l1,l2) in zip(window[:-1],window[1:]) if l1[0]!=l2[0]]
        if len(s1) > 2:
            sys.stderr.write("WARNING: ground truth labels (%s) merged!\n" % str(s1))

def confidence_print_window(window, args):
    try:
        g = set([g for g,l,c in window])
    except:
        sys.stderr.write("ERROR: classfification confidence missing (run predict with -l)")
        sys.exit(-1)
    _,l,_ = max(window, key=lambda c: c[2])

    if len(g) > 1:
        sys.stderr.write("WARNING: ground truth labels (%s) merged!\n" % str(g))

    print(list(g)[-1],l)

def score_print_window(window, args):
    try:
        g = set([g for g,l,c in window])
        d = { key: 0 for (_,key,_) in window }
        for _,key,c in window: d[key] += float(c)
    except:
        sys.stderr.write("ERROR: classfification confidence missing (run predict with -l)")
        sys.exit(-1)
    l = max(d.items(), key=lambda i: i[1])[0]

    if len(g) > 1:
        sys.stderr.write("WARNING: ground truth labels (%s) merged!\n" % str(g))

    print(list(g)[-1],l)

def main_loop(print_window, args):
    # sanity check for supplied arguments
    if args.overlap < 0 or args.overlap >=1:
        sys.stderr.write("-O|--overlap must be in the range [0,1)\n")
        sys.exit(-1)

    if args.window <= 0:
        sys.stderr.write("-W|--window must be larger than 0")
        sys.exit(-1)

    window = []

    for line in fileinput.input(args.files):
        if line.strip()=="" or line.strip()[0] == "#":
            continue

        window.append(line.split())

        if len(window) == args.window:
            print_window(window,args)
            window = window[int(ceil(len(window)*(1-args.overlap))):]

    if len(window) > 0:
        print_window(window,args)

if __name__=="__main__":
    if args.command == "majority":
        main_loop(major_print_window, args)
    elif args.command == "confidence":
        main_loop(confidence_print_window, args)
    elif args.command == "score":
        main_loop(score_print_window, args)
    elif args.command == "change":
        lastline = None

        for line in fileinput.input(args.files):
            if line.strip()=="" or line.strip()[0] == "#":
                continue

            if line!=lastline:
                lastline = line
                print(line)


#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import argparse,sys,subprocess,shlex,tempfile,os,shutil,re,struct,time,json
from threading import Thread as T
from datetime import timedelta as td
from select import select
from string import whitespace as ws
from struct import Struct, error
from queue import Queue

def ass2rate(s,rate):
    h,m,s = [float(x) for x in s.split(':')]
    return int( (24*60*h+60*m+s) * rate )

def unpack_to_str(streams,sub,default,style,verbose=False):
    # use -af aresample=resampler=soxr -ar 100 to switch to a common output rate
    # and merge all stream. The amerge complex filter can't be used since it can
    # not be taught to use the soxr resampler (the default one does not work)
    # This is only done when resampling is neccesary.

    files = list(set(f for (d,f) in streams))
    subasfile = sub and not sub[0]['file_index'] in (d['file_index'] for (d,_) in streams)

    # a special case, when the subtitle is in its own file
    if subasfile: files.append(sub[1])

    # setup all input, output and subtitle pipes
    ins   = [py3k(os.pipe()) for x in files]
    outs  = [py3k(os.pipe()) for x in streams]
    subp  =  py3k(os.pipe()) if sub else None

    # figure out the largest sample_rate for upsampling
    rate  = max([int(d['sample_rate']) for (d,f) in streams])

    # build the command line
    cmd  = 'ffmpeg'
    cmd += '' if verbose else ' -hide_banner -loglevel quiet'
    cmd += ''.join(' -i pipe:%d'%r for r,_ in ins)
    cmd += '' if not sub else ' -map %d:%d -f ass pipe:%d'%(sub[0]['file_index'],sub[0]['index'],subp[1])

    for (d,f),(_,w) in zip(streams,outs):
        cmd += ' -map %d:%d'%(d['file_index'],d['index'])
        cmd += ' -f f32le -ar %f'%rate
        cmd += '' if len(outs)==1 else ' -af aresample=resampler=soxr:linear_interp=1'
        cmd += ' pipe:%d'%w

    # cmdline built, now copy all files to their respective w parts of in,
    # and read the results for r parts of outs. Do the same for the sub
    if verbose: sys.stderr.write(cmd+"\n")

    pid = os.fork()
    if not pid:
        for (_,w) in ins: os.close(w)
        for (r,_) in outs+([subp] if sub else []): os.close(r)

        cmd = cmd.split()
        os.execvp(cmd[0],cmd)
    else:
        for (r,_) in ins: os.close(r)
        for (_,w) in outs+([subp] if sub else []): os.close(w)

        subr = os.fdopen(subp[0],'r') if sub else None
        ins  = [os.fdopen(w,'wb',buffering=2**12) for (_,w) in ins]
        outs = [os.fdopen(r,'rb',buffering=2**12) for (r,_) in outs]

        # we need to know the number of channelsl for each stream
        # to calculate the number of bytes to read for each stream
        chns = [int(d['channels']) for (d,f) in streams]

        # keep track of the one subtitle stream
        BUFSIZE  = 8192
        default  = re.sub('\s+','_',default.strip())
        t,b,e,l  = 0,0,float("inf") if not sub else float("-inf"),default
        si,so    = outs+[subr], ins
        inputbuf = { k : [] for k in outs }
        done     = False

        # this is more or less the select loop
        while not done and len(si) > 0:
            r,w,_ = select(si,so,[],.1)

            for o in w: # ffmpeg is ready to receive new data
                i = files[ins.index(o)]
                d = i.read(BUFSIZE)
                if len(d)==0: i.close(); o.close(); so.remove(o);
                else: o.write(d)

            if subr in r and e<=t:
                try:
                    srt = subr.readline()
                    _,begs,end,s,_,_,_,_,_,label = srt.split(',')
                    label = re.sub('\s+','_',label.strip())
                    beg,end = ass2rate(begs,rate),ass2rate(end,rate)

                    if (style is None or style==s) and beg < e and l!=default:
                        raise Exception("overlapping labels (%s,%s) at %s"%(label,l,begs))
                    elif style is None or style==s:
                        b,e,l = beg,end,label

                except ValueError as err:
                    if len(srt) == 0: subr.close(); si.remove(subr)

            for i in [x for x in r if x is not subr]:
                c = chns[outs.index(i)]
                buf = i.read(c*4)
                if len(buf) == 0:
                    done = True; continue
                frame = struct.unpack('%df'%c, buf)
                inputbuf[i].append(frame)

            while all(len(v)>0 for v in inputbuf.values()):
                t += 1
                if e<=t: l = default
                bufs = [ str(y) for x in inputbuf.values() for y in x.pop(0)]
                print (l," ".join(bufs))

        pid,status = os.waitpid(pid,0)


def py3k(tup):
    """ brain-deadness of py3k """
    for x in tup: os.set_inheritable(x,True)
    return tup

def group(files):
    sub,result,filecount = None,[],0

    for streams in files:
        for desc,fd in streams:
            desc['file_index'] = filecount

            if desc['codec_type'] == 'subtitle':
                sub = (desc,fd)
            elif desc['codec_type'] == 'audio':
                result.append( (desc,fd) )
            else:
                raise Exception("got unhandled codec_type %s"%desc['codec_type'])

        if sub:
            yield result,sub
            sub,result,filecount = None,[],0
        else:
            filecount += 1

    # stuff without subtitle
    if len(result):
        yield result,None


def probe(buf):
    cmd = "ffprobe -hide_banner -loglevel quiet -of json -show_streams -".split()
    cmd = subprocess.Popen(cmd,stdin=subprocess.PIPE,stdout=subprocess.PIPE)
    o,e = cmd.communicate(buf)
    return json.loads(o.decode("utf-8"))['streams']

def sid(s):
    if not 'tags' in s.keys():
        return None
    elif 'LANGUAGE' in s['tags'].keys():
        return s['tags']['LANGUAGE']
    elif 'NAME' in s['tags'].keys():
        return s['tags']['NAME']
    else:
        return None

if __name__ == '__main__':
    cmdline = argparse.ArgumentParser('unpacks .mkv file (using ffmpeg)')
    cmdline.add_argument('files', type=str, default=["-"], nargs='*',       help="input files")
    cmdline.add_argument('-d', '--default', type=str, default="NULL",       help="default class label for unlabelled data")
    cmdline.add_argument('-s', '--style', type=str, default=None,           help="the class label style to select")
    cmdline.add_argument('-t', '--stream', type=str, nargs='*', default=[], help="select streams to consider by their meta-tag *language* or *name*, multiple can be given ")
    cmdline.add_argument('-v', '--verbose', action="store_true", help="more verbose output")
    args = cmdline.parse_args()

    # we open each file here already and create an input buffer
    # for probing each input and then writing the read data to
    # ffmpeg in order to not have to read something twice
    iopen = lambda f: open(f,'rb',buffering=2**21)
    sopen = lambda f: os.fdopen(sys.stdin.fileno(),'rb',buffering=2**21)
    files = (iopen(f) if f != '-' else sopen(f) for f in args.files )
    files = [ (probe(f.peek(int(2*1e6))),f) for f in files ]
    sids  = [ sid(s) for (ss,f) in files for s in ss if s['codec_type']=='audio' ]

    # checks if audio or subtitle stream
    okay = lambda d: d['codec_type']=='subtitle' or\
            args.stream==[] and d['codec_type']=='audio' or\
            'tags' in d.keys() and d['codec_type']=='audio' and (\
                   'LANGUAGE' in d['tags'].keys() and d['tags']['LANGUAGE'] in args.stream or\
                       'NAME' in d['tags'].keys() and d['tags']['NAME'] in args.stream)

    # filter out all streams which are not neccesary or selected
    files = [[(s,f) for s in ss if okay(s)] for (ss,f) in files ]

    for audio,sub in group(files):
        if not audio:
            err = "no data stream selected, possible are: %s\n"%str(sids)
            sys.stderr.write(err)
            sys.exit(-1)

        unpack_to_str(audio,sub,args.default,args.style,args.verbose)

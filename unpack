#!/usr/bin/env python
# -*- encoding: utf-8 -*-

import argparse,sys,subprocess,shlex,tempfile,os,shutil,re
from datetime import timedelta as td
from string import whitespace
from select import select
from struct import Struct, error
from math import ceil,floor
from sys import stderr

SRT = re.compile(r'(\d+).\n?'
        r'(?P<start>\d{2}:\d{2}:\d{2},\d{3}) --> '
        r'(?P<end>\d{2}:\d{2}:\d{2},\d{3}).\n?'
        r'(?P<text>.+?)(\n\n?|$)', re.DOTALL|re.MULTILINE)
ASS = re.compile(r'Dialogue: (.+)')
WS  = re.compile(r'\s+')

def group_files(files, stream=[]):
    """ collects files into groups of subtitle and audio tracks. Tracks have to
    be ordered for that, i.e. given the list of files and stream names there can
    only be groups of two matching audio and subtitle tracks.
    """
    # get stream id and metadata from each input
    ms = ((subprocess.check_output("ffprobe %s"%f,shell=True,stderr=subprocess.STDOUT).decode("utf-8"),f) for f in files)
    ms = ((re.search("Stream #(\d+:\d+)(\(.*?\))?: (?:(?:(Audio): .*, (\d+) Hz, (\d+.\d+))|(?:(Subtitle): ))", str(line)),f) for (s,f) in ms for line in s.split("\n"))
    ms = ((x.groups(),f) for (x,f) in ms if x)
    ms = [(f,id, name[1:-1] if name else "", int(rate) if rate else None, sum(int(x) for x in c.split('.')) if c else None, t1 or t2) for ((id,name,t1,rate,c,t2),f) in ms]
    ns = [(f,i,n,r,c,t) for (f,i,n,r,c,t) in ms if len(stream)==0 or n in stream]

    # check if we have any
    if len(ns) == 0:
        raise Exception("no input files after selection, have you specified any selectors?\nPossible values are:\n %s"%"\n ".join([n for (f,i,n,r,c,t) in ms]))

    if len(ns)%2 != 0:
        raise Exception("uneven number of input streams")

    return [(a,b) if a[-1]=="Audio" else (b,a) for a,b in zip(ms[0::2],ms[1::2])]

def unpack_to_str(audio,sub, default="NULL", style="Default", do_flush=True):
    """ unpacks a .mkv file to a string representation, if it contains an audio
    and subtitle track. Without a subtitle track just unpacks an audio track
    with the default label.
    """
    tmpdir = tempfile.mkdtemp()
    data,subtitle = os.path.join(tmpdir,"data"),os.path.join(tmpdir,"sub")

    try:
        os.mkfifo(data)
        os.mkfifo(subtitle)

        audio,audio_stream,_,rate,channels,_ = audio
        sub,sub_stream,_,_,_,_ = sub

        cmd    = "ffmpeg -i %s -y -f:%s f32le %s -i %s -y -f:%s ass %s"%(audio,audio_stream,data,sub,sub_stream,subtitle)
        ffmpeg = subprocess.Popen(cmd,shell=True)

        data,subtitle = open(data,"rb"), open(subtitle,"r")
        tic,fmt,buf   = 0, Struct("%df"%channels), []
        b,e,l         = None,None,None

        def ticks(s):
            h,m,s,ms = [int(x) for x in s.replace('.',':').split(':')]
            return ceil((h*60*60*1000 + m*60*1000 + s*1000 + ms*10) / (1000./rate))

        while True:
            r,_,_ = select([data,subtitle],[],[],10)

            if data in r:
                d = data.read(fmt.size)
                buf.append([str(x) for x in fmt.unpack(d)])

            if subtitle in r and (e is None or tic>=e):
                match = ASS.search(subtitle.readline())
                if match:
                    _,_b,_e,s,_,_,_,_,_,l = match.group(1).split(',')

                    if style is not None and s!=style:
                        continue

                    b,e = ticks(_b),ticks(_e)

                    if b<tic:
                        raise Exception("overlapping labels are not supported")

            while (not e is None and tic<e) and len(buf)>0:
                label = l if tic>=b else default
                print(WS.sub('_',label),*buf.pop(),sep="\t")
                tic += 1
    except error as e:
        pass # happens when we read the whole file
    except:
        raise
    finally:
        if 'buf' in vars():
            while len(buf)>0 and do_flush:
                print("NULL",*buf.pop(),sep="\t")
            ffmpeg.terminate()
            data.close()
            subtitle.close()
        shutil.rmtree(tmpdir)

if __name__ == '__main__':
    cmdline = argparse.ArgumentParser('unpacks .mkv file (using ffmpeg)')
    cmdline.add_argument('files', type=str, nargs='+', help="input files")
    cmdline.add_argument('-d', '--default', type=str, default="NULL",       help="default class label for unlabelled data")
    cmdline.add_argument('-s', '--style', type=str, default=None,           help="the class label style to select")
    cmdline.add_argument('-n', '--no-flush', action="store_false",          help="if specified stops output after the last label")
    cmdline.add_argument('-t', '--stream', type=str, nargs='*', default=[], help="select streams to consider by their meta-tag *language* or *name*")
    args = cmdline.parse_args()

    for audio,sub in group_files(args.files,args.stream):
        unpack_to_str(audio,sub,args.default,args.style,args.no_flush)
